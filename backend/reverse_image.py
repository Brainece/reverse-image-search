from fastapi import FastAPI, File, UploadFile, Depends, HTTPException, status, Response, Request
from fastapi.middleware.cors import CORSMiddleware
from PIL import Image
from fastapi.security import OAuth2PasswordBearer, OAuth2PasswordRequestForm
import io
from pydantic import BaseModel
from datetime import datetime, timedelta
from jose import JWTError, jwt
from passlib.context import CryptContext
from typing import Optional
from datetime import datetime, timedelta
from fastapi.staticfiles import StaticFiles

# ml libraries
import joblib
import pandas as pd
import numpy as np
from sklearn.metrics.pairwise import cosine_similarity

# torch libraries
import torch
import torch.nn as nn
from torchvision import models, transforms

# security imports
from auth_sec import authenticate_user, get_current_active_user, get_password_hash, verify_password, create_access_token, get_user, get_current_user 
from auth_sec import Token, TokenData, User, UserInDB

# db details - to be removed and replaced with real db
db = {
    "samba": {
        "username": "samba",
        "fullname": "Brian Samba",
        "email": "oluochboss@gmail.com",
        "hashed_password": "$2b$12$sD39SzXB4NEaDXHhQ/IWBupLJGfSjuTM1XgmbCkdtZ2Nz3ny62Z62",
        "disabled": False
    },
    "liz": {
        "username": "gacheru",
        "fullname": "Elizabeth Gacheru",
        "email": "gacheru@gmail.com",
        "hashed_password": "$2b$12$sD39SzXB4NEaDXHhQ/IWBupLJGfSjuTM1XgmbCkdtZ2Nz3ny62Z62",
        "disabled": False
    },
     "kennedy": {
        "username": "machoka",
        "fullname": "Kennedy Machoka",
        "email": "machoka@gmail.com",
        "hashed_password": "$2b$12$sD39SzXB4NEaDXHhQ/IWBupLJGfSjuTM1XgmbCkdtZ2Nz3ny62Z62",
        "disabled": False
    }

}

# security constants
SECRET_KEY = "e0a9247bd28c290de76152b1b2784f8809a9837ee6470ec590967e037ddb36b3" # generated by openssl rand -hex 32
ALGORITHM = "HS256"
ACCESS_TOKEN_EXPIRE_MINUTES = 30 # access token expires after 30 minutes
REFRESH_TOKEN_EXPIRE_MINUTES = 60 * 24 * 7 # refresh token expires after 7 days

pwd_context = CryptContext(schemes=["bcrypt"], deprecated="auto")
oauth2_scheme = OAuth2PasswordBearer(tokenUrl="login")




app = FastAPI()
#router = APIRouter()

IMG_DIR = "../notebooks/archive/images/"
#"/home/brian/Documents/Portfolio/image_search/reverse-image-search/notebooks/archive/images/"

# mount the images directory to a URL Endpoint
#app.mount("/images", app.static_files, directory="images", html=True)
app.mount("/images", StaticFiles(directory=IMG_DIR), name="images") 

model = None

#database_embeddings_path = "./df_embs.pkl" #joblib.load("df_embs.pkl")
#atabase_image_paths = None
allEmbs = None # embeddings for all images
device = torch.device("cuda" if torch.cuda.is_available() else "cpu")

# config cors
origins = [
    "http://localhost:5173",
    "http://127.0.0.1:5173",
    "http://localhost:8000",
]

app.add_middleware(
    CORSMiddleware,
    #allow_origins=origins,
    allow_origins=["*"],
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

# image preprocessing pipeline
preprocess = transforms.Compose([
    transforms.Resize(256),
    transforms.CenterCrop(224),
    transforms.ToTensor(),
    transforms.Normalize(mean=[0.485, 0.456, 0.406], std=[0.229, 0.224, 0.225])
])

def image_location(img):
    return "../notebooks/archive/images/" + img

def extract_embedding(img):
    pass


@app.on_event("startup")
async def load_resources():
    #global model, database_embeddings, database_image_paths
    global model, allEmbs
    print("Loading model and embeddings...")
    # load the pretrained ResNet18
    model = models.resnet18(weights=models.ResNet18_Weights.DEFAULT)
    # Remove the final fully connected layer to get feature vectors
    model = nn.Sequential(*list(model.children())[:-1])
    model.to(device)
    model.eval()

    try:
        with open("./embeddings/imgEmbs.pkl", "rb") as f:
            allEmbs = joblib.load(f)
        print("Embeddings loaded successfully")
    except Exception as e:
        print(f"Error loading embeddings: {e}")
        allEmbs = None

@app.post("/login/", response_model=Token)
async def login_for_access_token(response: Response, form_data: OAuth2PasswordRequestForm = Depends()):
    user = authenticate_user(db, form_data.username, form_data.password)
    if not user:
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="Incorrect username or password",
            headers={"WWW-Authenticate": "Bearer"},
        )
    access_token_expires = timedelta(minutes=ACCESS_TOKEN_EXPIRE_MINUTES)
    access_token = create_access_token(data={"sub": user.username}, expires_delta=access_token_expires)
    
    # refresh token
    refresh_token_expires = timedelta(minutes=REFRESH_TOKEN_EXPIRE_MINUTES)
    refresh_token = create_access_token(data={"sub": user.username}, expires_delta=refresh_token_expires)

    # set the refresh token as an HttpOnly cookie
    response.set_cookie(
        key="refresh_token",
        value=refresh_token,
        httponly=True,
        secure=True,
        samesite="strict",
        expires=REFRESH_TOKEN_EXPIRE_MINUTES * 60

    )

    return {"access_token": access_token, "token_type": "bearer"}

@app.post("/refresh-token/")
def refresh_token(request: Request, response: Response):
    refresh_token = request.cookies.get("refresh_token")
    if not refresh_token:
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="Refresh token not found",
            headers={"WWW-Authenticate": "Bearer"},
        )
    try:
        # decode the refresh token to check its validity
        payload = jwt.decode(refresh_token, SECRET_KEY, algorithms=[ALGORITHM])
        username = payload.get("sub")
        if username is None:
            raise HTTPException(
                status_code=status.HTTP_401_UNAUTHORIZED,
                detail="Invalid refresh token",
                headers={"WWW-Authenticate": "Bearer"},
            )
        access_token_expires = timedelta(minutes=ACCESS_TOKEN_EXPIRE_MINUTES)
        new_access_token = create_access_token(data={"sub": username}, expires_delta=access_token_expires)

        return {"access_token": new_access_token, "token_type": "bearer"}
    except jwt.ExpiredSignatureError:
        # clear the expired cookie to force re-login
        response.delete_cookie(key="refresh_token")
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="Refresh token expired",
            headers={"WWW-Authenticate": "Bearer"},
        )
    except Exception:
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="Invalid token",
        )    
@app.post("/search-image/")
async def search_similar_images(file: UploadFile = File(...), current_user: str = Depends(get_current_user)):
    if model is None or allEmbs is None:
        print(model, allEmbs)
        return {"error": "Model or embeddings not loaded. Please check the server logs"}
    
    try:
        contents = await file.read()
        # preprocess image to match the input shape of the model
        image = Image.open(io.BytesIO(contents)).convert('RGB')
        image_tensor = preprocess(image).unsqueeze(0).to(device)
        #print(image_tensor.shape)

        # Get the embedding of the query image
        with torch.no_grad():
            query_embedding = model(image_tensor).flatten().cpu().numpy().reshape(1, -1)

        #print(query_embedding.shape)

        # Find the most similar images
        # calculate the cosine similarity score between query embedding and all embeddings
        embeddings_matrix = allEmbs['embedding'].tolist()
        similarities = cosine_similarity(query_embedding, embeddings_matrix)[0]
        #similarities = cosine_similarity(query_embedding, df_embs)[0]

        # Get the top N similar images
        top_n = 5
        top_indices = similarities.argsort()[-top_n:][::-1]

        #print(top_indices)

        # Compile the results
        #similar_images = [
        #    {'image_path': allEmbs.iloc[i]['image'], 'similarity': similarities[i]} for i in top_indices
        #]
        similar_images = [
            {'image_path': str(allEmbs.iloc[i]['image']), 'similarity': float(similarities[i])} for i in top_indices
        ]

        #print(similar_images)

        return {"similar_images": similar_images}

    
    except Exception as e:
        return {"error": f"An error occurred during processing {e}"}, 400


@app.post("/logout/")
async def logout(response: Response):
    response.delete_cookie(key="refresh_token")
    return {"message": "Logged out successfully"}
